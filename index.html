<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Замер ковра по A4</title>

  <style>
    body { margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; background:#0b0f17; color:#e7eefc; }
    header { padding:14px; display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
    button { padding:10px 14px; border-radius:12px; border:1px solid #2b3f63; background:#1b2a44; color:#fff; font-weight:700; }
    .pill { padding:8px 10px; border-radius:999px; border:1px solid #2b3f63; background:#132038; font-weight:700; }
    #status { padding: 0 14px 12px; opacity:.9; font-size:14px; line-height:1.35; }
    canvas { width: calc(100% - 28px); margin: 0 14px 14px; border-radius:16px; border:1px solid #2b3f63; background:#05070c; min-height:60vh; display:block; }
    #video { position: fixed; left:-10000px; top:0; width: 1px; height: 1px; opacity:0; }
    .hint { padding:0 14px 14px; opacity:.78; font-size:12px; line-height:1.35; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  </style>

  <!-- OpenCV.js -->
  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
</head>

<body>
<header>
  <div class="row">
    <div class="pill">A4: <span id="a4">—</span></div>
    <div class="pill">Ковёр: <span id="rug">—</span></div>
  </div>
  <div class="row">
    <button id="btn">Старт</button>
    <button id="cam">Камера: задняя</button>
  </div>
</header>

<div id="status">Статус: жду OpenCV…</div>

<video id="video" playsinline muted></video>
<canvas id="canvas"></canvas>

<div class="hint">
  <b>Важно для A4:</b> положи лист на тёмный фон (или подложи тёмную ткань), без бликов от лампы. Лист должен быть целиком в кадре.
  <br/>Если хочешь 100% стабильность — обведи A4 чёрным маркером по контуру (один раз) или положи на него тёмную рамку (это резко повышает детект).
</div>

<script>
const A4_W_MM = 210;
const A4_H_MM = 297;
const A4_RATIO = A4_H_MM / A4_W_MM; // ~1.414

const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const btn = document.getElementById('btn');
const camBtn = document.getElementById('cam');

const statusEl = document.getElementById('status');
const a4El = document.getElementById('a4');
const rugEl = document.getElementById('rug');

const setStatus = (t) => statusEl.textContent = 'Статус: ' + t;

let running = false;
let stream = null;
let timer = null;

// задняя камера по умолчанию
let facingMode = 'environment'; // 'user' или 'environment'
camBtn.textContent = 'Камера: задняя';

// ---------- math/geom helpers ----------
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function avg(a,b){ return (a+b)/2; }

function orderQuad(pts) {
  const sum = pts.map(p => p.x + p.y);
  const diff = pts.map(p => p.x - p.y);
  const tl = pts[sum.indexOf(Math.min(...sum))];
  const br = pts[sum.indexOf(Math.max(...sum))];
  const tr = pts[diff.indexOf(Math.max(...diff))];
  const bl = pts[diff.indexOf(Math.min(...diff))];
  return [tl,tr,br,bl];
}

function quadSideLengths(quad) {
  const [tl,tr,br,bl] = quad;
  const top = dist(tl,tr);
  const right = dist(tr,br);
  const bottom = dist(br,bl);
  const left = dist(bl,tl);
  return { top,right,bottom,left };
}

function drawQuad(quad, color='rgba(0,255,153,0.95)', lw=4) {
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = lw;
  ctx.beginPath();
  ctx.moveTo(quad[0].x, quad[0].y);
  ctx.lineTo(quad[1].x, quad[1].y);
  ctx.lineTo(quad[2].x, quad[2].y);
  ctx.lineTo(quad[3].x, quad[3].y);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}

function drawLabel(text, x, y) {
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.fillRect(x, y-24, 310, 28);
  ctx.fillStyle = '#e7eefc';
  ctx.font = '700 16px system-ui,-apple-system,Segoe UI,Roboto,Arial';
  ctx.fillText(text, x+8, y-6);
  ctx.restore();
}

// ---------- OpenCV core ----------
function findQuadsFromBinary(binary) {
  // binary: single-channel 0/255
  let contours = new cv.MatVector();
  let hierarchy = new cv.Mat();
  cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  const quads = [];

  for (let i=0; i<contours.size(); i++) {
    const cnt = contours.get(i);
    const area = cv.contourArea(cnt);
    if (area < 5000) { cnt.delete(); continue; }

    const peri = cv.arcLength(cnt, true);
    const approx = new cv.Mat();
    cv.approxPolyDP(cnt, approx, 0.02 * peri, true);

    if (approx.rows === 4 && cv.isContourConvex(approx)) {
      const pts = [];
      for (let r=0; r<4; r++) {
        const x = approx.intPtr(r,0)[0];
        const y = approx.intPtr(r,0)[1];
        pts.push({x,y});
      }
      const quad = orderQuad(pts);
      quads.push({ quad, area });
    }

    approx.delete();
    cnt.delete();
  }

  contours.delete(); hierarchy.delete();
  return quads;
}

function buildBinaryEdges(gray) {
  // edges pipeline: blur -> canny -> dilate
  let g = new cv.Mat();
  cv.GaussianBlur(gray, g, new cv.Size(5,5), 0, 0, cv.BORDER_DEFAULT);

  let edges = new cv.Mat();
  cv.Canny(g, edges, 60, 160);

  let kernel = cv.Mat.ones(3,3, cv.CV_8U);
  cv.dilate(edges, edges, kernel);

  g.delete(); kernel.delete();
  return edges; // must delete later
}

function buildBinaryWhite(gray) {
  // white sheet pipeline: normalize -> adaptive threshold -> close
  let g = new cv.Mat();
  // выравниваем освещение
  cv.GaussianBlur(gray, g, new cv.Size(7,7), 0);

  let bin = new cv.Mat();
  // adaptive threshold помогает при неравномерном свете
  cv.adaptiveThreshold(g, bin, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 31, 5);

  // морфологическое закрытие, чтобы лист был цельным
  let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(7,7));
  cv.morphologyEx(bin, bin, cv.MORPH_CLOSE, kernel);

  g.delete(); kernel.delete();
  return bin; // must delete later
}

function pickA4(quads) {
  let best = null;
  for (const q of quads) {
    const sides = quadSideLengths(q.quad);
    const w = avg(sides.top, sides.bottom);
    const h = avg(sides.left, sides.right);
    const ratio = Math.max(w,h) / Math.min(w,h);

    // A4 соотношение сторон ~1.414, допускаем погрешность
    const okRatio = Math.abs(ratio - A4_RATIO) < 0.28; // шире допуск для жизни
    if (!okRatio) continue;

    // A4 не должен быть слишком огромным (если слишком близко к камере)
    if (q.area < 8000) continue;

    // выбираем самый "уверенный" по площади
    if (!best || q.area > best.area) best = { ...q, wpx:w, hpx:h, ratio };
  }
  return best;
}

function pickRug(quads, a4Candidate) {
  let best = null;
  for (const q of quads) {
    if (a4Candidate && Math.abs(q.area - a4Candidate.area) < a4Candidate.area * 0.2) continue;
    if (!best || q.area > best.area) best = q;
  }
  return best;
}

function fmtMeters(mm) { return (mm/1000).toFixed(2); }

function processFrame() {
  if (!running) return;
  if (!video.videoWidth || !video.videoHeight) return;

  // рисуем видео
  if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
  }
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  // OpenCV read
  let rgba = cv.imread(canvas);
  let gray = new cv.Mat();
  cv.cvtColor(rgba, gray, cv.COLOR_RGBA2GRAY);

  // 1) пробуем через "белый лист"
  const binWhite = buildBinaryWhite(gray);
  const quadsWhite = findQuadsFromBinary(binWhite);

  // 2) пробуем через грани
  const binEdges = buildBinaryEdges(gray);
  const quadsEdges = findQuadsFromBinary(binEdges);

  // объединяем кандидаты
  const quadsAll = [...quadsWhite, ...quadsEdges];

  // cleanup mats
  rgba.delete(); gray.delete(); binWhite.delete(); binEdges.delete();

  const a4 = pickA4(quadsAll);
  const rug = pickRug(quadsAll, a4);

  if (!a4) {
    a4El.textContent = 'не найден';
    rugEl.textContent = '—';
    setStatus('Не вижу A4. Попробуй: тёмная подложка под A4 + убрать блики + держать камеру выше/ровнее.');
    return;
  }

  // scale (mm per pixel) по двум сторонам A4
  const sides = quadSideLengths(a4.quad);
  const wpx = Math.min(avg(sides.top, sides.bottom), avg(sides.left, sides.right));
  const hpx = Math.max(avg(sides.top, sides.bottom), avg(sides.left, sides.right));
  const mmPerPxW = A4_W_MM / wpx;
  const mmPerPxH = A4_H_MM / hpx;
  const mmPerPx = (mmPerPxW + mmPerPxH) / 2;

  a4El.textContent = `ok (${mmPerPx.toFixed(3)} мм/px)`;
  drawQuad(a4.quad, 'rgba(0,255,153,0.95)', 4);
  drawLabel('A4', a4.quad[0].x, a4.quad[0].y);

  if (!rug) {
    rugEl.textContent = 'не найден';
    setStatus('Вижу A4, но ковёр не выделился как прямоугольник. Нужен контраст ковра с полом / больше света.');
    return;
  }

  const rs = quadSideLengths(rug.quad);
  const rwpx = avg(rs.top, rs.bottom);
  const rhpx = avg(rs.left, rs.right);
  const longPx = Math.max(rwpx, rhpx);
  const shortPx = Math.min(rwpx, rhpx);

  const longMm = longPx * mmPerPx;
  const shortMm = shortPx * mmPerPx;
  const areaM2 = (longMm/1000) * (shortMm/1000);

  rugEl.textContent = `${fmtMeters(longMm)}×${fmtMeters(shortMm)} м | ${areaM2.toFixed(2)} м²`;
  drawQuad(rug.quad, 'rgba(255,200,0,0.95)', 5);
  drawLabel('КОВЁР', rug.quad[0].x, rug.quad[0].y);

  setStatus('Готово. Если цифры прыгают — держи телефон ровнее и добавь света.');
}

// ---------- camera start/stop ----------
async function start() {
  setStatus('запрашиваю камеру…');

  stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode, width: { ideal: 1920 }, height: { ideal: 1080 } },
    audio: false
  });

  video.srcObject = stream;
  await video.play();

  running = true;
  btn.textContent = 'Стоп';
  setStatus('камера запущена. Наведи на ковёр + A4…');

  // ~8 fps
  timer = setInterval(processFrame, 125);
}

function stop() {
  running = false;
  btn.textContent = 'Старт';
  setStatus('остановлено');

  if (timer) { clearInterval(timer); timer = null; }

  if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
  video.srcObject = null;

  a4El.textContent = '—';
  rugEl.textContent = '—';

  ctx.clearRect(0,0,canvas.width,canvas.height);
}

// ---------- OpenCV ready hook ----------
function waitForOpenCVReady() {
  if (typeof cv === 'undefined' || !cv.Mat) return setTimeout(waitForOpenCVReady, 100);
  cv.onRuntimeInitialized = () => setStatus('OpenCV готов. Нажми “Старт”.');
}
waitForOpenCVReady();

// ---------- UI ----------
btn.addEventListener('click', async () => {
  try {
    if (!running) await start();
    else stop();
  } catch (e) {
    console.error(e);
    alert('Ошибка запуска. Важно: открыть по HTTPS и разрешить камеру.');
    stop();
  }
});

camBtn.addEventListener('click', async () => {
  // переключаем камеру
  facingMode = (facingMode === 'environment') ? 'user' : 'environment';
  camBtn.textContent = (facingMode === 'environment') ? 'Камера: задняя' : 'Камера: фронтальная';

  // если уже работает — перезапускаем поток
  if (running) {
    stop();
    await start();
  }
});
</script>
</body>
</html>
