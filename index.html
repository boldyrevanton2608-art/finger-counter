<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Замер ковра по A4 (быстрый)</title>

  <style>
    body { margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; background:#0b0f17; color:#e7eefc; }
    header { padding:14px; display:flex; gap:10px; align-items:center; justify-content:space-between; flex-wrap:wrap; }
    button { padding:10px 14px; border-radius:12px; border:1px solid #2b3f63; background:#1b2a44; color:#fff; font-weight:700; }
    .pill { padding:8px 10px; border-radius:999px; border:1px solid #2b3f63; background:#132038; font-weight:700; }
    #status { padding: 0 14px 12px; opacity:.9; font-size:14px; line-height:1.35; }
    canvas { width: calc(100% - 28px); margin: 0 14px 14px; border-radius:16px; border:1px solid #2b3f63; background:#05070c; min-height:60vh; display:block; }
    #video { position: fixed; left:-10000px; top:0; width:1px; height:1px; opacity:0; }
    .hint { padding:0 14px 14px; opacity:.78; font-size:12px; line-height:1.35; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
  </style>

  <script async src="https://docs.opencv.org/4.x/opencv.js"></script>
</head>

<body>
<header>
  <div class="row">
    <div class="pill">A4: <span id="a4">—</span></div>
    <div class="pill">Ковёр: <span id="rug">—</span></div>
    <div class="pill">FPS: <span id="fps">—</span></div>
  </div>
  <div class="row">
    <button id="btn">Старт</button>
    <button id="cam">Камера: задняя</button>
  </div>
</header>

<div id="status">Статус: жду OpenCV…</div>

<video id="video" playsinline muted></video>
<canvas id="canvas"></canvas>

<div class="hint">
  ✅ Клади A4 <b>на ковёр</b> и ориентируй длинной стороной как ковёр. <br/>
  ✅ Свет — ярче, без бликов. Телефон держи выше и ровнее. <br/>
  ⚡ Оптимизация: обработка идёт на уменьшенной копии кадра (быстрее, меньше лагов).
</div>

<script>
const A4_W_MM = 210;
const A4_H_MM = 297;
const A4_RATIO = A4_H_MM / A4_W_MM; // ~1.414

const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

const btn = document.getElementById('btn');
const camBtn = document.getElementById('cam');

const statusEl = document.getElementById('status');
const a4El = document.getElementById('a4');
const rugEl = document.getElementById('rug');
const fpsEl = document.getElementById('fps');

const setStatus = (t) => statusEl.textContent = 'Статус: ' + t;

let running = false;
let stream = null;

// по умолчанию — задняя камера
let facingMode = 'environment';
camBtn.textContent = 'Камера: задняя';

// --- PERFORMANCE TUNING ---
const PROCESS_EVERY_MS = 220;   // ~4-5 обработок/сек (стабильно на телефоне)
const PROC_TARGET_W = 640;      // ширина уменьшенной копии кадра для OpenCV
let lastProcessAt = 0;

// offscreen canvas для обработки (уменьшенный кадр)
const procCanvas = document.createElement('canvas');
const procCtx = procCanvas.getContext('2d');

// fps счётчик
let fpsFrames = 0;
let fpsLast = performance.now();

function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
function avg(a,b){ return (a+b)/2; }

function orderQuad(pts) {
  const sum = pts.map(p => p.x + p.y);
  const diff = pts.map(p => p.x - p.y);
  const tl = pts[sum.indexOf(Math.min(...sum))];
  const br = pts[sum.indexOf(Math.max(...sum))];
  const tr = pts[diff.indexOf(Math.max(...diff))];
  const bl = pts[diff.indexOf(Math.min(...diff))];
  return [tl,tr,br,bl];
}

function quadSideLengths(quad) {
  const [tl,tr,br,bl] = quad;
  return {
    top: dist(tl,tr),
    right: dist(tr,br),
    bottom: dist(br,bl),
    left: dist(bl,tl)
  };
}

function drawQuad(quad, color='rgba(0,255,153,0.95)', lw=4) {
  ctx.save();
  ctx.strokeStyle = color;
  ctx.lineWidth = lw;
  ctx.beginPath();
  ctx.moveTo(quad[0].x, quad[0].y);
  ctx.lineTo(quad[1].x, quad[1].y);
  ctx.lineTo(quad[2].x, quad[2].y);
  ctx.lineTo(quad[3].x, quad[3].y);
  ctx.closePath();
  ctx.stroke();
  ctx.restore();
}

function drawLabel(text, x, y) {
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.fillRect(x, y-24, 360, 28);
  ctx.fillStyle = '#e7eefc';
  ctx.font = '700 16px system-ui,-apple-system,Segoe UI,Roboto,Arial';
  ctx.fillText(text, x+8, y-6);
  ctx.restore();
}

function findQuadsFromBinary(binary) {
  let contours = new cv.MatVector();
  let hierarchy = new cv.Mat();
  cv.findContours(binary, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  const quads = [];
  for (let i=0; i<contours.size(); i++) {
    const cnt = contours.get(i);
    const area = cv.contourArea(cnt);
    if (area < 2500) { cnt.delete(); continue; }

    const peri = cv.arcLength(cnt, true);
    const approx = new cv.Mat();
    cv.approxPolyDP(cnt, approx, 0.02 * peri, true);

    if (approx.rows === 4 && cv.isContourConvex(approx)) {
      const pts = [];
      for (let r=0; r<4; r++) {
        const x = approx.intPtr(r,0)[0];
        const y = approx.intPtr(r,0)[1];
        pts.push({x,y});
      }
      quads.push({ quad: orderQuad(pts), area });
    }

    approx.delete();
    cnt.delete();
  }

  contours.delete(); hierarchy.delete();
  return quads;
}

function buildBinaryWhite(gray) {
  // Для A4 на ковре часто работает лучше, чем Canny
  let g = new cv.Mat();
  cv.GaussianBlur(gray, g, new cv.Size(7,7), 0);

  let bin = new cv.Mat();
  cv.adaptiveThreshold(g, bin, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 31, 5);

  // Закрытие дырок
  let kernel = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(7,7));
  cv.morphologyEx(bin, bin, cv.MORPH_CLOSE, kernel);

  g.delete(); kernel.delete();
  return bin;
}

function pickA4(quads) {
  let best = null;
  for (const q of quads) {
    const s = quadSideLengths(q.quad);
    const w = avg(s.top, s.bottom);
    const h = avg(s.left, s.right);
    const ratio = Math.max(w,h) / Math.min(w,h);

    // допуск: жизнь
    if (Math.abs(ratio - A4_RATIO) > 0.30) continue;

    // A4 должен быть не слишком маленьким
    if (q.area < 4000) continue;

    if (!best || q.area > best.area) best = { ...q, wpx:w, hpx:h, ratio };
  }
  return best;
}

function pickRug(quads, a4) {
  let best = null;
  for (const q of quads) {
    if (a4 && Math.abs(q.area - a4.area) < a4.area * 0.25) continue;
    if (!best || q.area > best.area) best = q;
  }
  return best;
}

function fmtMeters(mm) { return (mm/1000).toFixed(2); }

function processFrameOpenCV(scaleToMainX, scaleToMainY) {
  // читаем procCanvas в OpenCV
  let rgba = cv.imread(procCanvas);
  let gray = new cv.Mat();
  cv.cvtColor(rgba, gray, cv.COLOR_RGBA2GRAY);

  const binWhite = buildBinaryWhite(gray);
  const quads = findQuadsFromBinary(binWhite);

  rgba.delete(); gray.delete(); binWhite.delete();

  const a4Small = pickA4(quads);
  const rugSmall = pickRug(quads, a4Small);

  if (!a4Small) {
    a4El.textContent = 'не найден';
    rugEl.textContent = '—';
    setStatus('Не вижу A4. Клади A4 на ковёр, убери блики, держи выше/ровнее.');
    return;
  }

  // переводим координаты quad из уменьшенного кадра в основной canvas
  const a4 = {
    area: a4Small.area,
    quad: a4Small.quad.map(p => ({ x: p.x * scaleToMainX, y: p.y * scaleToMainY }))
  };

  const a4Sides = quadSideLengths(a4.quad);

  // оценим пиксели A4 (в ОСНОВНОМ кадре)
  const a4Wpx = Math.min(avg(a4Sides.top, a4Sides.bottom), avg(a4Sides.left, a4Sides.right));
  const a4Hpx = Math.max(avg(a4Sides.top, a4Sides.bottom), avg(a4Sides.left, a4Sides.right));

  // масштаб мм/пиксель
  const mmPerPx = ((A4_W_MM / a4Wpx) + (A4_H_MM / a4Hpx)) / 2;
  a4El.textContent = `ok (${mmPerPx.toFixed(3)} мм/px)`;

  drawQuad(a4.quad, 'rgba(0,255,153,0.95)', 4);
  drawLabel('A4', a4.quad[0].x, a4.quad[0].y);

  if (!rugSmall) {
    rugEl.textContent = 'не найден';
    setStatus('Вижу A4, но ковёр не выделился прямоугольником. Нужен контраст/свет.');
    return;
  }

  const rug = {
    area: rugSmall.area,
    quad: rugSmall.quad.map(p => ({ x: p.x * scaleToMainX, y: p.y * scaleToMainY }))
  };

  const rs = quadSideLengths(rug.quad);
  const rwpx = avg(rs.top, rs.bottom);
  const rhpx = avg(rs.left, rs.right);

  const longPx = Math.max(rwpx, rhpx);
  const shortPx = Math.min(rwpx, rhpx);

  const longMm = longPx * mmPerPx;
  const shortMm = shortPx * mmPerPx;
  const areaM2 = (longMm/1000) * (shortMm/1000);

  rugEl.textContent = `${fmtMeters(longMm)}×${fmtMeters(shortMm)} м | ${areaM2.toFixed(2)} м²`;

  drawQuad(rug.quad, 'rgba(255,200,0,0.95)', 5);
  drawLabel('КОВЁР', rug.quad[0].x, rug.quad[0].y);

  setStatus('Ок. Если цифры прыгают — держи телефон ровнее, больше света, A4 ближе к центру.');
}

function loop() {
  if (!running) return;
  requestAnimationFrame(loop);

  if (!video.videoWidth || !video.videoHeight) return;

  // рисуем видео в основной canvas (гладко, без лагов)
  if (canvas.width !== video.videoWidth || canvas.height !== video.videoHeight) {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
  }
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  // FPS display
  fpsFrames++;
  const now = performance.now();
  if (now - fpsLast > 1000) {
    fpsEl.textContent = String(Math.round((fpsFrames * 1000) / (now - fpsLast)));
    fpsFrames = 0;
    fpsLast = now;
  }

  // OpenCV — реже и на уменьшенном кадре
  if (now - lastProcessAt < PROCESS_EVERY_MS) return;
  lastProcessAt = now;

  const mainW = canvas.width;
  const mainH = canvas.height;

  const procW = PROC_TARGET_W;
  const procH = Math.round(procW * (mainH / mainW));

  procCanvas.width = procW;
  procCanvas.height = procH;

  procCtx.drawImage(video, 0, 0, procW, procH);

  const scaleToMainX = mainW / procW;
  const scaleToMainY = mainH / procH;

  // поверх текущего кадра рисуем результаты
  processFrameOpenCV(scaleToMainX, scaleToMainY);
}

async function start() {
  setStatus('запрашиваю камеру…');

  // Для скорости лучше не 4K: 1280x720 обычно оптимально
  stream = await navigator.mediaDevices.getUserMedia({
    video: { facingMode, width: { ideal: 1280 }, height: { ideal: 720 } },
    audio: false
  });

  video.srcObject = stream;
  await video.play();

  running = true;
  btn.textContent = 'Стоп';
  setStatus('камера запущена. Наведи на ковёр + A4…');

  lastProcessAt = 0;
  fpsFrames = 0;
  fpsLast = performance.now();

  requestAnimationFrame(loop);
}

function stop() {
  running = false;
  btn.textContent = 'Старт';
  setStatus('остановлено');

  if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
  video.srcObject = null;

  a4El.textContent = '—';
  rugEl.textContent = '—';
  fpsEl.textContent = '—';
  ctx.clearRect(0,0,canvas.width,canvas.height);
}

// OpenCV ready hook
function waitForOpenCVReady() {
  if (typeof cv === 'undefined' || !cv.Mat) return setTimeout(waitForOpenCVReady, 100);
  cv.onRuntimeInitialized = () => setStatus('OpenCV готов. Нажми “Старт”.');
}
waitForOpenCVReady();

// UI
btn.addEventListener('click', async () => {
  try {
    if (!running) await start();
    else stop();
  } catch (e) {
    console.error(e);
    alert('Ошибка запуска. Важно: открыть по HTTPS и разрешить камеру.');
    stop();
  }
});

camBtn.addEventListener('click', async () => {
  facingMode = (facingMode === 'environment') ? 'user' : 'environment';
  camBtn.textContent = (facingMode === 'environment') ? 'Камера: задняя' : 'Камера: фронтальная';
  if (running) { stop(); await start(); }
});
</script>
</body>
</html>
